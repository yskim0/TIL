## C++ 강좌

> STL - 페어 pair

값 2개의 쌍인데, 서로 다른 자료형의 값 2개를 한꺼번에 저장함.

```cpp
#include <iostream>

#include <utility>

using namespace std;

 

int main(){

 

 pair<int, char> p(15, 'H');

 cout << p.first << ' ' << p.second << endl;

 p.first = 40;

 p.second = '*';

 cout << p.first << ' ' << p.second << endl;

 

 return 0;

}
```

- 먼저 `utility` 헤더 파일 선언
- pair는 서로 크기 비교를 할 때 first 멤버가 더 크면 pair 자체가 더 큰 것이고
first 멤버가 서로 같으면 second 멤버가 더 커야 pair 자체가 더 큼.
- 둘 다 같으면 완전히 같음.


```cpp
#include <iostream>
#include <utility>
using namespace std;

int main(){
    pair<int, int> p (15,7), q(22,3), r(15,5);
    cout << (p<q) << endl;
    cout << (q<r) << endl;
    cout << (p<r) << endl;

    return 0;
}
```

```
1
0
0
[커서]
```

```cpp

#include <iostream>

#include <string>

#include <queue>

#include <utility>

using namespace std;

 

int main(){

 

 priority_queue< pair<int, string> > PQueue;

 int n;

 string s;

 while(1){

  cin >> n;

  if(n == 0) break;

  cin >> s;

  PQueue.push(pair<int, string>(n, s));

 }

 

 while(!PQueue.empty()){

  cout << PQueue.top().first << "번 이름: " << PQueue.top().second << endl;

  PQueue.pop();

 }

 

 return 0;

}
```

```
5 xhae[엔터]

2 zzapcoder[엔터]

8 apple_cplus[엔터]

1 hahaha[엔터]

6 baekjoon[엔터]

3 portableangel[엔터]

4 august14[엔터]

9 nada[엔터]

7 pichulia[엔터]

0[엔터]

9번 이름: nada

8번 이름: apple_cplus

7번 이름: pichulia

6번 이름: baekjoon

5번 이름: xhae

4번 이름: august14

3번 이름: portableangel

2번 이름: zzapcoder

1번 이름: hahaha

[커서]
```

- pair에 typedef 적용하기

```cpp
#include <iostream>

#include <string>

#include <queue>

#include <utility>

using namespace std;

 

int main(){

 

 typedef pair<int, string> intStringPair;

 priority_queue<intStringPair> PQueue;

 int n;

 string s;

 while(1){

  cin >> n;

  if(n == 0) break;

  cin >> s;

  PQueue.push(intStringPair(n, s));

 }

 

 while(!PQueue.empty()){

  cout << PQueue.top().first << "번 이름: " << PQueue.top().second << endl;

  PQueue.pop();

 }

 

 return 0;

}
```

---

> STL - 맵 map

세트가 단순히 값의 존재 유무만을 따졌다면, 맵은 값의 조재와 동시에 그에 연동된 또다른 값도 저장함.

이터레이터로 순회할 때도 단순히 `*iter`가 아니라 `*iter->first, *iter->second`로 순회함.

```cpp
#include <iostream>

#include <map>

#include <cctype>

using namespace std;

 

int main(){

 

 map<char, int> m;

 char input;

 while(1){

  input = cin.get();

  if(!islower(input)) break;

  if(m.count(input)) m[input]++;

  else m[input] = 1;

 }

 for(char c = 'a'; c <= 'z'; c++)

  cout << c << ": " << m[c] << endl;

 

 return 0;

}
```

맵은 함수를 이용해 값을 집어넣지 않고 **배열 다루듯이 값을 사용함.**
- [] 오퍼레이터를 오버로딩 해놓았기 때문.

`m[input] = 1`
- 맵 m의 input 키값의 연동된 값이 1이 됨.



**이터레이터 활용해보기**

```cpp
#include <iostream>

#include <map>

#include <cctype>

using namespace std;

 

int main(){

 

 map<char, int> m;

 char input;

 while(1){

  input = cin.get();

  if(!islower(input)) break;

  if(m.count(input)) m[input]++;

  else m[input] = 1;

 }

 for(map<char, int>::iterator iter=m.begin(); iter!=m.end(); iter++)

  cout << iter->first << ": " << iter->second << endl;

 

 return 0;

}
```

```
millionaire[엔터]

a: 1

e: 1

i: 3

l: 2

m: 1

n: 1

o: 1

r: 1

[커서]
```

map 역시 **키 값에 대해 정렬되어 있음.**
- map과 set은 상당히 비슷한 구조를 가지고 있음.
- 실제로 구현도 같은 자료구조로 되어 있음.


키 값이 어떤 자료형도 가능하다는 것을 보기 위해, 문자열을 키값으로 사용해보기.


```cpp
#include <iostream>

#include <map>

#include <string>

using namespace std;

 

int main(){

 

 map<string, int> m;

 string input;

 int n, score;

 cin >> n;

 for(int i=0; i<n; i++){

  cin >> input >> score;

  m[input] = score;

 }

 for(map<string, int>::iterator iter=m.begin(); iter!=m.end(); iter++)

  cout << iter->first << ": " << iter->second << "점" << endl;

 

 return 0;

}
```

```
5[엔터]

nero 50[엔터]

makjang 30[엔터]

susuro 40[엔터]

bonogoon 70[엔터]

gyack 60[엔터]

bonogoon: 70점

gyack: 60점

makjang: 30점

nero: 50점

susuro: 40점

[커서]
```

- `m["rie"]=0;` 을 사용해도 문제 없이 작동함.
- map의 확장 : *멀티맵*


**C+11 이상 버전에서는 간단히 순회 가능**

```cpp
#include <iostream>
#include <map>
#include <cctype>
using namespace std;

int main() {
    map<char,int> m;
    char input;
    while (1) {
        input = cin.get();
        if (!islower(input)) break;
        if (m.count(input)) m[input]++;
        else m[input] = 1;
    }
    for (pair<char,int> current:m)
        cout << current.first << ":" << current.second << endl;
    return 0;
}
```

auto로 써놓아도 컴파일러가 유추함.

```cpp
#include <iostream>

#include <map>

#include <cctype>

using namespace std;



int main() {



 map<char, int> m;

 char input;

 while (1) {

  input = cin.get();

  if (!islower(input)) break;

  if (m.count(input)) m[input]++;

  else m[input] = 1;

 }

 for(auto current: m)

  cout << current.first << ": " << current.second << endl;



 return 0;

}
```

pair가 아닌 훨씬 더 복잡한 클래스가 들어오게 될 경우 `auto&` 등으로 레퍼런스 사용.

---

> 중첩 클래스 - 중첩 클래스 소개

```cpp
#include <iostream>
using namespace std;

class outerClass{

public:
 outerClass():n(0){}
 outerClass(int m):n(m){}
 void outerFunction(){
  cout << "바깥쪽 클래스 함수입니다. n = " << n << endl;
 }

 class innerClass{
 public:
  innerClass():f(0){}
  innerClass(double g):f(g){}
  void innerFunction(){
   cout << "안쪽 클래스 함수입니다. f = " << f << endl;
  }

 private:
  double f;
 };

private:
 int n;
};

int main(){
 outerClass A(4);
 outerClass::innerClass B(6.7);
 A.outerFunction();
 B.innerFunction();
 return 0;
}
```

- outerClass 내부에 innerClass가 정의되어 있음.
- innerClass는 클래스 형을 정의한 것이지 아직 오브젝트는 아님.
    - outerClass 또는 외부에서 innerClass라는 이름으로 접근할 수는 없음.
- innerClass는 외부에서 `innerClass C(5.0);` 이렇게 접근할 수 없고,
`outerClass::innerClass B(6.7);` 이렇게 접근해야 함.
- 그 다음 접근부터는 오브젝트 명만 쓰면 됨.

**main.cpp**
```cpp
#include <iostream>

#include "myClass.h"

using namespace std;

 

int main(){

 

 outerClass A(4);

 outerClass::innerClass B(6.7);

 A.outerFunction();

 B.innerFunction();

 

 return 0;

}
```

**myClass.h**
```cpp
#ifndef MYCLASS

#define MYCLASS

 

class outerClass{

public:

 outerClass();

 outerClass(int m);

 void outerFunction();

 

 class innerClass{

 public:

  innerClass();

  innerClass(double g);

  void innerFunction();

 private:

  double f;

 };

private:

 int n;

};

 

#endif
```

**myClass.cpp**
```cpp
#include <iostream>

#include "myClass.h"

using namespace std;

 

outerClass::outerClass():n(0){

}

 

outerClass::outerClass(int m):n(m){

}

 

void outerClass::outerFunction(){

 cout << "바깥쪽 클래스 함수입니다. n = " << n << endl;

}

 

outerClass::innerClass::innerClass():f(0){

}

 

outerClass::innerClass::innerClass(double g):f(g){

}

 

void outerClass::innerClass::innerFunction(){

 cout << "안쪽 클래스 함수입니다. f = " << f << endl;

}
```

하지만 지금까지는 innerClass가 public 영역에 있기 때문에 외부에서 접근이 가능했었음.
만약 private 영역에 있다면?

**myClass.h**
```cpp
#ifndef MYCLASS

#define MYCLASS

 

class outerClass{

public:

 outerClass();

 outerClass(int m);

 void outerFunction();

private:

 int n;

 

 class innerClass{

 public:

  innerClass();

  innerClass(double g);

  void innerFunction();

 private:

  double f;

 };

};

 

#endif
```

보통은 이렇게 private 영역에 중첩 클래스를 정의하는 경우가 많음.
특정 클래스 안에서만 사용하는 또다른 클래스 자료형이 필요할 경우에 이렇게 함.
- 캡슐화 원칙에 따라 private으로 지정해 숨기는 것.

---

> 중첩 클래스 - private 중첩 클래스 사용

**record.h**
```cpp
#ifndef RECORD

#define RECORD

 

#include <iostream>

#include <string>

using namespace std;

 

class Record{

public:

 Record();

 Record(int score1, string subjectName1);

 int getScore();

 string getSubjectName();

 

private:

 int score;

 string subjectName;

};

 

#endif
```

**record.cpp**
```cpp
#include "record.h"

 

Record::Record():score(0),subjectName(""){

}

 

Record::Record(int score1, string subjectName1):score(score1),subjectName(subjectName1){

}

 

int Record::getScore(){

 return score;

}

 

string Record::getSubjectName(){

 return subjectName;

}
```

**student.h**
```cpp
#ifndef STUDENT

#define STUDENT

 

#include <iostream>

#include <string>

#include "record.h"

#define MAX 10

using namespace std;

 

class Student{

public:

 Student();

 Student(string name1);

 void addScore(int score1, string subjectName1);

 void printAllScore();

 

private:

 string name;

 int subjectSize;

 Record recordList[MAX];

};

 

#endif
```

**student.cpp**
```cpp
#include "student.h"

 

Student::Student():name(""),subjectSize(0){

}

 

Student::Student(string name1):name(name1),subjectSize(0){

}

 

void Student::addScore(int score1, string subjectName1){

 if(subjectSize == MAX){

  cout << "이미 과목이 꽉 찼습니다!" << endl;

  return;

 }

 recordList[subjectSize++] = Record(score1, subjectName1);

}

 

void Student::printAllScore(){

 cout << '<' << name << "> 학생 성적" << endl;

 for(int i=0; i<subjectSize; i++)

  cout << recordList[i].getSubjectName() << " 과목: "

   << recordList[i].getScore() << "점" << endl;

}
```

**main.cpp**
```cpp
#include <iostream>

#include "student.h"

using namespace std;

 

int main(){

 

 Student A("Nero"), B("Bonogoon");

 A.addScore(80, "전자기학");

 A.addScore(75, "컴퓨터교육학");

 A.addScore(12, "암호학개론");

 A.addScore(100, "미분적분학");

 B.addScore(90, "정수론");

 B.addScore(97, "현대사회와심리학");

 

 A.printAllScore();

 B.printAllScore();

 

 return 0;

}
```

```
<Nero> 학생 성적

전자기학 과목: 80점

컴퓨터교육학 과목: 75점

암호학개론 과목: 12점

미분적분학 과목: 100점

<Bonogoon> 학생 성적

정수론 과목: 90점

현대사회와심리학 과목: 97점

[커서]
```

문제없이 잘 작동됨.
하지만 여기서 `Record` 클래스를 중첩 구조로 바꿀 것.
이 클래스는 Student의 멤버 변수로만 등장하기 때문에 **캡슐화**를 위해 정의부도 숨길 것임.

**student.h**

```cpp
#ifndef STUDENT

#define STUDENT

 

#include <iostream>

#include <string>

#define MAX 10

using namespace std;

 

class Student{

public:

 Student();

 Student(string name1);

 void addScore(int score1, string subjectName1);

 void printAllScore();

 

private:

 class Record{

 public:

  Record();

  Record(int score1, string subjectName1);

  int getScore();

  string getSubjectName();

 

 private:

  int score;

  string subjectName;

 };

 

 string name;

 int subjectSize;

 Record recordList[MAX];

};

 

#endif
```

**student.cpp**
```cpp
#include "student.h"

 

Student::Student():name(""),subjectSize(0){

}

 

Student::Student(string name1):name(name1),subjectSize(0){

}

 

void Student::addScore(int score1, string subjectName1){

 if(subjectSize == MAX){

  cout << "이미 과목이 꽉 찼습니다!" << endl;

  return;

 }

 recordList[subjectSize++] = Record(score1, subjectName1);

}

 

void Student::printAllScore(){

 cout << '<' << name << "> 학생 성적" << endl;

 for(int i=0; i<subjectSize; i++)

  cout << recordList[i].getSubjectName() << " 과목: "

   << recordList[i].getScore() << "점" << endl;

}

 

Student::Record::Record():score(0),subjectName(""){

}

 

Student::Record::Record(int score1, string subjectName1):score(score1),subjectName(subjectName1){

}

 

int Student::Record::getScore(){

 return score;

}

 

string Student::Record::getSubjectName(){

 return subjectName;

}
```

---

> 중첩 클래스 - 템플릿과 중첩 클래스의 결합

- 바깥 클래스만 템플릿을 사용할 경우

**myClass.h**
```cpp
#ifndef MYCLASS

#define MYCLASS

 

template<typename T>

class outerClass{

public:

 outerClass();

 outerClass(T newValue);

 void setOuterValue(T newValue);

 T getOuterValue();

 

 class innerClass{

 public:

  innerClass();

  innerClass(int newValue);

  void setInnerValue(int newValue);

  int getInnerValue();

 

 private:

  int innerValue;

 };

 

private:

 T outerValue;

};

 

#endif
```

**myClass.cpp**
```cpp
#include "myClass.h"

 

template<typename T>

outerClass<T>::outerClass():outerValue(0){

}

 

template<typename T>

outerClass<T>::outerClass(T newValue):outerValue(newValue){

}

 

template<typename T>

void outerClass<T>::setOuterValue(T newValue){

 outerValue = newValue;

}

 

template<typename T>

T outerClass<T>::getOuterValue(){

 return outerValue;

}

 

template<typename T>

outerClass<T>::innerClass::innerClass():innerValue(0){

}

 

template<typename T>

outerClass<T>::innerClass::innerClass(int newValue):innerValue(newValue){

}

 

template<typename T>

void outerClass<T>::innerClass::setInnerValue(int newValue){

 innerValue = newValue;

}

 

template<typename T>

int outerClass<T>::innerClass::getInnerValue(){

 return innerValue;

}
```

**main.cpp**
```cpp
#include <iostream>

#include "myClass.h"

#include "myClass.cpp"

using namespace std;

 

int main(){

 

 outerClass<double> O(3.14);

 cout << O.getOuterValue() << endl;

 O.setOuterValue(4.17);

 cout << O.getOuterValue() << endl;

 

 outerClass<double>::innerClass I(12);

 cout << I.getInnerValue() << endl;

 I.setInnerValue(-66);

 cout << I.getInnerValue() << endl;

 

 return 0;

}
```

- 템플릿이니까 cpp 파일도 선언해야 함.
- innerClass의 경우 템플릿을 사용하지도 않는데 `outerClass<자료형>::`을 붙여줘야 함.


**바깥쪽 클래스와 안쪽 클래스가 같은 형 변수를 사용하는 경우**

**myClass.h**
```cpp
#ifndef MYCLASS

#define MYCLASS

 

template<typename T>

class outerClass{

public:

 outerClass();

 outerClass(T newValue);

 void setOuterValue(T newValue);

 T getOuterValue();

 

 class innerClass{

 public:

  innerClass();

  innerClass(T newValue);

  void setInnerValue(T newValue);

  T getInnerValue();

 

 private:

  T innerValue;

 };

 

private:

 T outerValue;

};

 

#endif
```

**myClass.cpp**
```cpp
...

 

template<typename T>

void outerClass<T>::innerClass::setInnerValue(T newValue){

 innerValue = newValue;

}

 

template<typename T>

T outerClass<T>::innerClass::getInnerValue(){

 return innerValue;

}
```

**main.cpp**
```cpp
#include <iostream>

#include "myClass.h"

#include "myClass.cpp"

using namespace std;

 

int main(){

 

 outerClass<double> O(3.14);

 cout << O.getOuterValue() << endl;

 O.setOuterValue(4.17);

 cout << O.getOuterValue() << endl;

 

 outerClass<double>::innerClass I(3.14);

 cout << I.getInnerValue() << endl;

 I.setInnerValue(4.17);

 cout << I.getInnerValue() << endl;

 

 return 0;

}
```

**바깥과 안쪽 클래스가 서로 다른 형 변수를 사용하는 경우**

**myClass.h**
```cpp
#ifndef MYCLASS

#define MYCLASS

 

template<typename T>

class outerClass{

public:

 outerClass();

 outerClass(T newValue);

 void setOuterValue(T newValue);

 T getOuterValue();

 

 template<typename U>

 class innerClass{

 public:

  innerClass();

  innerClass(U newValue);

  void setInnerValue(U newValue);

  U getInnerValue();

 

 private:

  U innerValue;

 };

 

private:

 T outerValue;

};

 

#endif
```

**myClass.cpp**

```cpp
...

 

template<typename T>

template<typename U>
outerClass<T>::innerClass<U>::innerClass():innerValue(0){

}

 

template<typename T>

template<typename U>

outerClass<T>::innerClass<U>::innerClass(U newValue):innerValue(newValue){

}

 

template<typename T>

template<typename U>

void outerClass<T>::innerClass<U>::setInnerValue(U newValue){

 innerValue = newValue;

}

 

template<typename T>

template<typename U>

U outerClass<T>::innerClass<U>::getInnerValue(){

 return innerValue;

}
```

**main.cpp**
```cpp
#include <iostream>

#include "myClass.h"

#include "myClass.cpp"

using namespace std;

 

int main(){

 

 outerClass<double> O(3.14);

 cout << O.getOuterValue() << endl;

 O.setOuterValue(4.17);

 cout << O.getOuterValue() << endl;

 

 outerClass<double>::innerClass<int> I(12);

 cout << I.getInnerValue() << endl;

 I.setInnerValue(-66);

 cout << I.getInnerValue() << endl;

 

 return 0;

}
```

- 복잡한 구문을 피하기 위해서는 아예 클래스 정의부에서 멤버 함수도 전부 정의해버리는 방법도 있음.

---


